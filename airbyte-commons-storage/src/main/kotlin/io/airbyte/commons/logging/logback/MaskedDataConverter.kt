/*
 * Copyright (c) 2020-2024 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.commons.logging.logback

import ch.qos.logback.classic.pattern.ClassicConverter
import ch.qos.logback.classic.spi.ILoggingEvent
import com.fasterxml.jackson.core.type.TypeReference
import io.airbyte.commons.constants.AirbyteCatalogConstants.LOCAL_SECRETS_MASKS_PATH
import io.airbyte.commons.constants.AirbyteSecretConstants
import io.airbyte.commons.yaml.Yamls
import java.nio.charset.Charset
import java.util.regex.Pattern

/**
 * Custom [ClassicConverter] used to intercept all log messages and mask any JSON
 * properties in the message that match the list of maskable properties.
 * <p>
 * The maskable properties file is generated by a Gradle task in the
 * {@code :oss:airbyte-config:specs} project. The file is named {@code specs_secrets_mask.yaml} and
 * is located in the {@code src/main/resources/seed} directory of the
 * {@code :oss:airbyte-config:init} project.
 */
class MaskedDataConverter(
  specMaskFile: String = LOCAL_SECRETS_MASKS_PATH,
) : ClassicConverter() {
  private val pattern: Pattern? = buildPattern(specMaskFile = specMaskFile)
  private val replacePattern = API_KEY_PATTERN.toPattern()

  override fun convert(event: ILoggingEvent): String = replace(message = applyMask(message = event.formattedMessage))

  /**
   * Applies the mask to the message, if necessary.
   *
   * @param message The log message.
   * @return The possibly masked log message.
   */
  private fun applyMask(message: String): String {
    val piiScrubbedMessage = removeKnownPii(message)
    return pattern?.matcher(piiScrubbedMessage)?.replaceAll(REPLACEMENT_PATTERN) ?: piiScrubbedMessage
  }

  /**
   * Builds the maskable property matching pattern.
   *
   * @param specMaskFile The spec mask file.
   * @return The regular expression pattern used to find maskable properties.
   */
  private fun buildPattern(specMaskFile: String): Pattern? =
    getMaskableProperties(specMaskFile).takeIf { it.isNotEmpty() }?.let {
      generatePattern(it).toPattern()
    }

  /**
   * Generates the property matching pattern string from the provided set of properties.
   *
   * @param properties The set of properties to match.
   * @return The generated regular expression pattern used to match the maskable properties.
   */
  private fun generatePattern(properties: Set<String>): String =
    buildString {
      append(CASE_INSENSITIVE_FLAG)
      append(PROPERTY_MATCHING_PATTERN_PREFIX)
      append(properties.joinToString("|"))
      append(PROPERTY_MATCHING_PATTERN_SUFFIX)
    }

  /**
   * Loads the maskable properties from the provided file.
   *
   * @param specMaskFile The spec mask file.
   * @return The set of maskable properties.
   */
  private fun getMaskableProperties(specMaskFile: String): Set<String> {
    return runCatching {
      val maskFileContents =
        javaClass.getResourceAsStream(specMaskFile)?.readBytes()?.toString(Charset.defaultCharset())
          ?: return setOf()

      val properties: Map<String, Set<String>> =
        Yamls.deserialize(maskFileContents, object : TypeReference<Map<String, Set<String>>>() {})

      properties.getOrDefault(PROPERTIES_KEY, setOf())
    }.getOrDefault(setOf())
  }

  /**
   * Code-based implementation of the `replace(message){r, t}` macro in Logback/Log4j configuration.
   *
   * @param message The message to apply replacement to.
   * @return The potentially modified message with any speciric patterns replaced.
   */
  private fun replace(message: String): String = replacePattern.matcher(message).replaceAll(API_KEY_REPLACEMENT)
}

/**
 * Regular expression to match api keys in strings.  Ported from previous Log4j2 configuration.
 */
private const val API_KEY_PATTERN = """apikey=[\w\-]*"""

/**
 * Replacement pattern for matches using the [API_KEY_PATTERN] regular expression.
 */
private const val API_KEY_REPLACEMENT = "apikey=${AirbyteSecretConstants.SECRETS_MASK}"

/**
 * Regular expression pattern flag that enables case in-sensitive matching.
 */
private const val CASE_INSENSITIVE_FLAG: String = "(?i)"

// This is a little circuitous, but it gets the regex syntax highlighting in intelliJ to work.
private val DESTINATION_ERROR_PREFIX: String = """^(?<destinationPrefix>.*destination.*\s+>\s+ERROR.+)""".toPattern().pattern()

/**
 * Regular expression replacement pattern for applying the mask to PII log messages.
 */
private const val KNOWN_PII_LOG_MESSAGE_REPLACEMENT_PATTERN: String = "\${destinationPrefix}\${messagePrefix}${AirbyteSecretConstants.SECRETS_MASK}"

private val KNOWN_PII_PATTERNS: List<Pattern> =
  listOf(
    """$DESTINATION_ERROR_PREFIX(?<messagePrefix>Received\s+invalid\s+message:)(.+)$""".toPattern(),
    """$DESTINATION_ERROR_PREFIX(?<messagePrefix>org\.jooq\.exception\.DataAccessException: SQL.+values\s+\()(.+)$""".toPattern(),
  )

/**
 * Name of the key in the mask YAML file that contains the list of maskable properties.
 */
private const val PROPERTIES_KEY: String = "properties"

/**
 * Regular expression pattern prefix for applying the mask to property values.
 */
private const val PROPERTY_MATCHING_PATTERN_PREFIX: String = """"("""

/**
 * Regular expression pattern suffix for applying the mask to property values.
 */
private const val PROPERTY_MATCHING_PATTERN_SUFFIX: String = """)"\s*:\s*("(?:[^"\\]|\\.)*"|\[[^]\[]*]|\d+)"""

/**
 * Regular expression pattern used to replace a key/value property with a masked value while
 * maintaining the property key/name.
 */
private const val REPLACEMENT_PATTERN: String = """"$1":"${AirbyteSecretConstants.SECRETS_MASK}""""

/**
 * Removes known PII from the message.
 *
 * @param message the log line
 * @return a redacted log line
 */
private fun removeKnownPii(message: String): String =
  KNOWN_PII_PATTERNS.fold(message) { msg, pattern ->
    pattern.matcher(msg).replaceAll(KNOWN_PII_LOG_MESSAGE_REPLACEMENT_PATTERN)
  }
